<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AFL 2026 Ladder Prediction â€¢ Prototype</title>

  <style>
    :root{
      --c1:#202a37;
      --c2:#202836;
      --c3:#10162b;
      --green:#03be6c;
      --yellow:#efe300;
      --red:#bb1726;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --border: rgba(255,255,255,.10);
      --shadow: 0 16px 50px rgba(0,0,0,.45);
      --radius: 18px;
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(3,190,108,.20), transparent 60%),
        radial-gradient(900px 600px at 85% 18%, rgba(239,227,0,.12), transparent 60%),
        radial-gradient(800px 600px at 60% 95%, rgba(187,23,38,.14), transparent 60%),
        linear-gradient(180deg, var(--c3), #0b1022 65%, #070b16);
      min-height:100vh;
    }

    .wrap{ max-width: 1150px; margin: 0 auto; padding: 22px; }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:14px; flex-wrap:wrap;
      margin-bottom: 18px;
    }
    .brand{ display:flex; align-items:center; gap:12px; }
    .logo{
      width:44px; height:44px; border-radius: 12px;
      background: linear-gradient(135deg, rgba(3,190,108,.25), rgba(239,227,0,.18));
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      overflow:hidden;
      display:grid; place-items:center;
    }
    .logo img{ width:100%; height:100%; object-fit:cover; display:block; }
    .logo-fallback{ font-weight:900; letter-spacing:.5px; color: var(--yellow); font-size: 16px; }

    h1{ margin:0; font-size: 20px; letter-spacing: .2px; }
    .sub{ margin-top:4px; color: var(--muted); font-size: 13px; }

    .btn{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(32,42,55,.55);
      color: var(--text);
      cursor:pointer;
      box-shadow: 0 10px 28px rgba(0,0,0,.25);
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(3,190,108,.35); background: rgba(32,42,55,.70); }
    .btn:active{ transform: translateY(0px); }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 16px;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(32,40,54,.70), rgba(32,42,55,.55));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 16px;
      display:flex; justify-content:space-between; align-items:baseline; gap:10px; flex-wrap:wrap;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(16,22,43,.35);
    }
    .title{ font-weight: 800; letter-spacing:.2px; }
    .hint{ color: var(--muted); font-size: 12px; }

    table{ width:100%; border-collapse: collapse; }
    th, td{ padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,.07); vertical-align: top; }
    th{ text-align:left; color: rgba(255,255,255,.78); font-size: 12px; text-transform: uppercase; letter-spacing: .10em; }
    td.right, th.right{ text-align:right; }

    tr.click{ cursor:pointer; }
    tr.click:hover{ background: rgba(3,190,108,.08); }
    tr.active{ background: rgba(3,190,108,.13); }

    /* Podium glow */
    tr.podium-1{ box-shadow: inset 0 0 0 9999px rgba(239,227,0,.05); }
    tr.podium-2{ box-shadow: inset 0 0 0 9999px rgba(255,255,255,.04); }
    tr.podium-3{ box-shadow: inset 0 0 0 9999px rgba(187,23,38,.05); }
    tr.podium-1 td:first-child,
    tr.podium-2 td:first-child,
    tr.podium-3 td:first-child{
      position: relative;
    }
    .podium-glow{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      margin-left: 6px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(16,22,43,.35);
      box-shadow: 0 0 20px rgba(239,227,0,.12);
      font-size: 12px;
      vertical-align: middle;
    }
    tr.podium-2 .podium-glow{ box-shadow: 0 0 20px rgba(255,255,255,.10); }
    tr.podium-3 .podium-glow{ box-shadow: 0 0 20px rgba(187,23,38,.12); }

    .tabs{
      display:flex; flex-wrap:wrap; gap:8px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(16,22,43,.25);
    }
    .tab{
      border-radius: 999px;
      padding: 8px 11px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(32,42,55,.50);
      color: rgba(255,255,255,.85);
      cursor:pointer;
      font-weight: 650;
      transition: border-color .2s ease, transform .08s ease, background .2s ease;
    }
    .tab:hover{ transform: translateY(-1px); border-color: rgba(239,227,0,.35); }
    .tab.active{
      background: rgba(239,227,0,.14);
      border-color: rgba(239,227,0,.35);
      color: #fff;
    }

    /* Mobile-friendly horizontal scroll for wide tables */
    .table-scroll{
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .table-scroll table{ min-width: 780px; }

    /* Chips under player name */
    .player-name{ font-weight: 850; line-height: 1.1; }
    .chips{
      margin-top: 6px;
      display:flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .chip{
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.78);
      background: rgba(16,22,43,.35);
      display:inline-flex;
      gap: 6px;
      align-items:center;
      max-width: 100%;
    }
    .chip strong{ color: rgba(255,255,255,.92); }
    .chip .k{ color: rgba(239,227,0,.90); font-weight: 900; }

    /* Trend arrow chip */
    .trend.up{ border-color: rgba(3,190,108,.30); background: rgba(3,190,108,.10); }
    .trend.down{ border-color: rgba(187,23,38,.30); background: rgba(187,23,38,.10); }
    .trend.flat{ border-color: rgba(255,255,255,.12); background: rgba(255,255,255,.05); }
    .trend .arrow{ font-size: 13px; }

    /* Expandable predicted ladder row (animated) */
    tr.expand-row td{
      padding: 0;
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: rgba(16,22,43,.22);
    }
    .expand-wrap{
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transform: translateY(-4px);
      transition: max-height 320ms ease, opacity 240ms ease, transform 240ms ease;
    }
    .expand-wrap.open{
      max-height: 900px; /* big enough for content */
      opacity: 1;
      transform: translateY(0px);
    }
    .expand-inner{ padding: 12px 14px 14px; }
    .mini-grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    @media (max-width: 820px){ .mini-grid{ grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 520px){ .mini-grid{ grid-template-columns: 1fr; } }

    .mini{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(32,42,55,.40);
    }
    .mini .mini-hd{
      padding: 10px 12px;
      font-weight: 850;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .mini table td{ padding: 10px 12px; }
    .mini table tr:last-child td{ border-bottom: 0; }

    /* Heat indicators */
    .heat{
      display:inline-flex;
      justify-content:center;
      min-width: 44px;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 900;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
    }
    .p10{ border-color: rgba(3,190,108,.35); background: rgba(3,190,108,.16); }
    .p5, .p4{ border-color: rgba(3,190,108,.25); background: rgba(3,190,108,.10); }
    .p3, .p2{ border-color: rgba(239,227,0,.28); background: rgba(239,227,0,.10); color: rgba(255,255,255,.92); }
    .p1{ border-color: rgba(187,23,38,.25); background: rgba(187,23,38,.10); }
    .p0{ opacity: .75; }

    .footer{ margin-top: 16px; color: var(--muted); font-size: 12px; }
    code.k{ color: rgba(239,227,0,.85); }

    /* Small */
    .small-muted{ color: var(--muted); font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo">
          <img src="./logo.png" alt="Site Logo" onerror="this.remove(); document.getElementById('logoFallback').style.display='grid';" />
          <div id="logoFallback" class="logo-fallback" style="display:none;">AFL</div>
        </div>
        <div>
          <h1>AFL 2026 Ladder Prediction <span style="opacity:.7;font-weight:700;">â€¢ Prototype</span></h1>
          <div class="sub" id="updatedAt">Last updated: â€”</div>
        </div>
      </div>

      <button class="btn" id="randomizeBtn">Regenerate Dummy Ladder</button>
    </div>

    <div class="grid">
      <!-- Leaderboard -->
      <div class="card">
        <div class="hd">
          <div class="title">Leaderboard</div>
          <div class="hint">Click a player row to expand their predicted ladder</div>
        </div>

        <table>
          <thead>
            <tr>
              <th style="width:90px;">Rank</th>
              <th>Player</th>
              <th class="right" style="width:110px;">Total</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>

        <div class="footer" style="padding: 12px 14px;">
          Scoring: <code class="k">0â†’10</code>, <code class="k">1â†’5</code>, <code class="k">2â†’4</code>, <code class="k">3â†’3</code>, <code class="k">4â†’2</code>, <code class="k">5â†’1</code>, <code class="k">6+â†’0</code>
          <span class="small-muted"> â€¢ Trends use dummy weekly history for now.</span>
        </div>
      </div>

      <!-- Current ladder -->
      <div class="card">
        <div class="hd">
          <div class="title">Current Ladder (Dummy)</div>
          <div class="hint">This is what youâ€™ll update weekly later</div>
        </div>
        <table>
          <thead>
            <tr>
              <th style="width:80px;">Pos</th>
              <th>Team</th>
            </tr>
          </thead>
          <tbody id="ladderBody"></tbody>
        </table>
      </div>

      <!-- Breakdown -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="hd">
          <div class="title">Player Breakdown</div>
          <div class="hint">On mobile, swipe sideways to see all columns</div>
        </div>

        <div class="tabs" id="tabs"></div>

        <div class="table-scroll">
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th class="right">Predicted</th>
                <th class="right">Actual</th>
                <th class="right">Diff</th>
                <th class="right">Points</th>
              </tr>
            </thead>
            <tbody id="breakdownBody"></tbody>
          </table>
        </div>

        <div class="footer" style="padding: 12px 14px;">
          Next step: wire this to Google Sheets + Apps Script so it updates weekly automatically.
        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Dummy data (AFL teams)
    // -----------------------------
    const TEAMS = [
      "Adelaide", "Brisbane", "Carlton", "Collingwood", "Essendon", "Fremantle",
      "Geelong", "Gold Coast", "GWS", "Hawthorn", "Melbourne", "North Melbourne",
      "Port Adelaide", "Richmond", "St Kilda", "Sydney", "West Coast", "Western Bulldogs"
    ];

    // Players (dummy)
    const PLAYERS = ["Jason", "Sam", "Alex", "Taylor", "Maddy", "Chris"];

    // -----------------------------
    // Scoring (your exact breakdown)
    // -----------------------------
    function scoreForDiff(diff){
      if (diff === 0) return 10;
      if (diff === 1) return 5;
      if (diff === 2) return 4;
      if (diff === 3) return 3;
      if (diff === 4) return 2;
      if (diff === 5) return 1;
      return 0;
    }

    // -----------------------------
    // Helpers
    // -----------------------------
    function shuffle(arr){
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function nowStamp(){ return new Date().toLocaleString(); }

    // Generate dummy "actual ladder" (random order)
    function generateActualLadder(){
      const order = shuffle(TEAMS);
      const ladder = {};
      order.forEach((team, idx) => ladder[team] = idx + 1);
      return ladder;
    }

    // Generate dummy player predictions:
    // start from actual ladder and apply random small swaps so it feels realistic.
    function generatePredictions(actualLadder){
      const actualOrder = TEAMS.slice().sort((a,b)=>actualLadder[a]-actualLadder[b]);

      function perturb(order, intensity){
        const a = [...order];
        for (let k = 0; k < intensity; k++){
          const i = Math.floor(Math.random() * a.length);
          const j = Math.max(0, Math.min(a.length - 1, i + (Math.random() < 0.5 ? -1 : 1)));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      const predictions = {};
      PLAYERS.forEach((p, idx) => {
        const intensity = 10 + idx * 4; // tweak realism
        const order = perturb(actualOrder, intensity);

        const ranks = {};
        order.forEach((team, i) => ranks[team] = i + 1);
        predictions[p] = ranks;
      });

      return predictions;
    }

    // Best team call: pick lowest diff (ties allowed, pick first alphabetically for display)
    function bestTeamCallForPlayer(breakdown){
      // breakdown items include team, diff, points
      let bestDiff = Infinity;
      breakdown.forEach(r => { if (r.diff < bestDiff) bestDiff = r.diff; });
      const candidates = breakdown.filter(r => r.diff === bestDiff).sort((a,b)=>a.team.localeCompare(b.team));
      const best = candidates[0];
      return {
        team: best?.team ?? "â€”",
        diff: Number.isFinite(best?.diff) ? best.diff : null,
        points: Number.isFinite(best?.points) ? best.points : null,
        ties: candidates.length
      };
    }

    // Compute leaderboard + breakdown + predicted ladder order
    function computeScores(actualLadder, predictions){
      const leaderboard = PLAYERS.map(name => {
        let total = 0;
        let exactHits = 0;

        const breakdown = TEAMS.map(team => {
          const predictedRank = predictions[name][team];
          const actualRank = actualLadder[team];
          const diff = Math.abs(predictedRank - actualRank);
          const points = scoreForDiff(diff);
          total += points;
          if (diff === 0) exactHits++;
          return { team, predictedRank, actualRank, diff, points };
        }).sort((a,b)=>a.actualRank-b.actualRank);

        const bestCall = bestTeamCallForPlayer(breakdown);

        const predictedOrder = TEAMS
          .slice()
          .sort((a,b)=>predictions[name][a]-predictions[name][b])
          .map(team => ({ team, pos: predictions[name][team] }));

        return { name, total, exactHits, bestCall, breakdown, predictedOrder };
      }).sort((a,b)=>b.total-a.total);

      return leaderboard;
    }

    // -----------------------------
    // Weekly history (dummy)
    // We simulate totals over 4 weeks leading into "this week"
    // so we can show trend arrows (Î” vs last week).
    // -----------------------------
    function makeWeeklyHistoryFromCurrent(currentActualLadder, predictions){
      // Create 4 "past weeks" by slightly shuffling the current ladder order.
      const weeks = [];
      const baseOrder = TEAMS.slice().sort((a,b)=>currentActualLadder[a]-currentActualLadder[b]);

      function smallShuffle(order, intensity){
        const a = [...order];
        for (let k=0;k<intensity;k++){
          const i = Math.floor(Math.random() * a.length);
          const j = Math.max(0, Math.min(a.length - 1, i + (Math.random()<0.5?-1:1)));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      const weekOrders = [
        smallShuffle(baseOrder, 18),
        smallShuffle(baseOrder, 12),
        smallShuffle(baseOrder, 8),
        baseOrder
      ];

      weekOrders.forEach((order, wIdx) => {
        const ladder = {};
        order.forEach((t,i)=> ladder[t]=i+1);
        const lb = computeScores(ladder, predictions);
        // Map totals by name for quick trend lookup
        const totalsByPlayer = {};
        lb.forEach(p => totalsByPlayer[p.name]=p.total);
        weeks.push({
          weekLabel: `Week ${wIdx+1}`,
          ladder,
          totalsByPlayer
        });
      });

      return weeks;
    }

    function trendForPlayer(weeks, playerName){
      if (!weeks || weeks.length < 2) return { delta: 0, dir: "flat" };
      const last = weeks[weeks.length - 1].totalsByPlayer[playerName] ?? 0;
      const prev = weeks[weeks.length - 2].totalsByPlayer[playerName] ?? 0;
      const delta = last - prev;
      if (delta > 0) return { delta, dir: "up" };
      if (delta < 0) return { delta, dir: "down" };
      return { delta: 0, dir: "flat" };
    }

    // -----------------------------
    // Render
    // -----------------------------
    const elUpdatedAt = document.getElementById("updatedAt");
    const elLeaderboardBody = document.getElementById("leaderboardBody");
    const elLadderBody = document.getElementById("ladderBody");
    const elTabs = document.getElementById("tabs");
    const elBreakdownBody = document.getElementById("breakdownBody");
    const elRandomizeBtn = document.getElementById("randomizeBtn");

    let state = {
      actualLadder: null,
      predictions: null,
      leaderboard: null,
      weeklyHistory: null,
      activePlayer: null,
      expandedPlayer: null
    };

    function medalForRank(rank){
      if (rank === 1) return "ðŸ¥‡";
      if (rank === 2) return "ðŸ¥ˆ";
      if (rank === 3) return "ðŸ¥‰";
      return "";
    }

    function podiumClass(rank){
      if (rank === 1) return "podium-1";
      if (rank === 2) return "podium-2";
      if (rank === 3) return "podium-3";
      return "";
    }

    function heatClass(points){
      if (points === 10) return "heat p10";
      if (points === 5) return "heat p5";
      if (points === 4) return "heat p4";
      if (points === 3) return "heat p3";
      if (points === 2) return "heat p2";
      if (points === 1) return "heat p1";
      return "heat p0";
    }

    function renderLadder(){
      const order = TEAMS.slice().sort((a,b)=>state.actualLadder[a]-state.actualLadder[b]);
      elLadderBody.innerHTML = order.map(team => `
        <tr>
          <td>${state.actualLadder[team]}</td>
          <td><b>${team}</b></td>
        </tr>
      `).join("");
    }

    function renderLeaderboard(){
      const lb = state.leaderboard || [];
      if (!state.activePlayer && lb.length) state.activePlayer = lb[0].name;

      const rows = [];
      lb.forEach((p, idx) => {
        const rank = idx + 1;
        const isActive = p.name === state.activePlayer;
        const isExpanded = p.name === state.expandedPlayer;

        const medal = medalForRank(rank);
        const podium = podiumClass(rank);

        const best = p.bestCall;
        const bestText = best?.team
          ? `${best.team}${best.ties > 1 ? " (tie)" : ""}`
          : "â€”";

        const tr = trendForPlayer(state.weeklyHistory, p.name);
        const arrow = tr.dir === "up" ? "â–²" : tr.dir === "down" ? "â–¼" : "â€¢";
        const deltaTxt = tr.delta === 0 ? "0" : (tr.delta > 0 ? `+${tr.delta}` : `${tr.delta}`);

        rows.push(`
          <tr class="click ${isActive ? "active" : ""} ${podium}"
              data-player="${p.name}"
              data-action="row">
            <td>
              ${rank}
              ${medal ? `<span class="podium-glow">${medal}</span>` : ""}
            </td>
            <td>
              <div class="player-name">${p.name}</div>
              <div class="chips">
                <span class="chip">Exact <span class="k">${p.exactHits}</span></span>
                <span class="chip">Best call <strong>${bestText}</strong></span>
                <span class="chip trend ${tr.dir}">
                  <span class="arrow">${arrow}</span>
                  Trend <strong>${deltaTxt}</strong>
                </span>
              </div>
            </td>
            <td class="right" style="font-weight:900;font-size:16px;">${p.total}</td>
          </tr>
        `);

        // Always render the expand row, but animate open/closed
        // (so the animation works reliably)
        const predicted = p.predictedOrder;
        const chunkSize = 6;
        const chunks = [];
        for (let i = 0; i < predicted.length; i += chunkSize){
          chunks.push(predicted.slice(i, i + chunkSize));
        }

        rows.push(`
          <tr class="expand-row">
            <td colspan="3">
              <div class="expand-wrap ${isExpanded ? "open" : ""}" data-expand-for="${p.name}">
                <div class="expand-inner">
                  <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:10px;">
                    <div style="font-weight:900;">${p.name}'s Predicted Ladder</div>
                    <div class="small-muted">Click the player row again to collapse</div>
                  </div>

                  <div class="mini-grid">
                    ${chunks.map((chunk, cIdx) => `
                      <div class="mini">
                        <div class="mini-hd">
                          <span>Positions ${cIdx*chunkSize+1}â€“${cIdx*chunkSize + chunk.length}</span>
                          <span class="chip">Predicted</span>
                        </div>
                        <table>
                          <tbody>
                            ${chunk.map(r => `
                              <tr>
                                <td style="width:70px; color: rgba(255,255,255,.75);">${r.pos}</td>
                                <td><b>${r.team}</b></td>
                              </tr>
                            `).join("")}
                          </tbody>
                        </table>
                      </div>
                    `).join("")}
                  </div>
                </div>
              </div>
            </td>
          </tr>
        `);
      });

      elLeaderboardBody.innerHTML = rows.join("");
    }

    function renderTabs(){
      const lb = state.leaderboard || [];
      elTabs.innerHTML = lb.map(p => {
        const cls = p.name === state.activePlayer ? "active" : "";
        return `<button class="tab ${cls}" data-player="${p.name}" data-action="tab">${p.name}</button>`;
      }).join("");
    }

    function renderBreakdown(){
      const lb = state.leaderboard || [];
      const player = lb.find(p => p.name === state.activePlayer) || lb[0];

      if (!player){
        elBreakdownBody.innerHTML = `<tr><td colspan="5">No players.</td></tr>`;
        return;
      }

      elBreakdownBody.innerHTML = player.breakdown.map(r => `
        <tr>
          <td>${r.team}</td>
          <td class="right">${r.predictedRank}</td>
          <td class="right">${r.actualRank}</td>
          <td class="right">${r.diff}</td>
          <td class="right"><span class="${heatClass(r.points)}">${r.points}</span></td>
        </tr>
      `).join("");
    }

    function renderAll(){
      elUpdatedAt.textContent = "Last updated: " + nowStamp();
      renderLadder();
      renderLeaderboard();
      renderTabs();
      renderBreakdown();
    }

    function regenerate(){
      state.actualLadder = generateActualLadder();
      state.predictions = generatePredictions(state.actualLadder);
      state.leaderboard = computeScores(state.actualLadder, state.predictions);

      // Build weekly history for trend arrows
      state.weeklyHistory = makeWeeklyHistoryFromCurrent(state.actualLadder, state.predictions);

      state.activePlayer = state.leaderboard[0]?.name ?? null;
      state.expandedPlayer = null;
      renderAll();
    }

    // Click handling
    document.addEventListener("click", (e) => {
      const node = e.target.closest("[data-action][data-player]");
      if (!node) return;

      const name = node.getAttribute("data-player");
      const action = node.getAttribute("data-action");

      if (action === "tab"){
        // Tabs only change the breakdown, no expand/collapse
        state.activePlayer = name;
        renderLeaderboard();
        renderTabs();
        renderBreakdown();
        return;
      }

      if (action === "row"){
        // Row click selects + toggles expansion
        state.activePlayer = name;
        state.expandedPlayer = (state.expandedPlayer === name) ? null : name;
        renderLeaderboard();
        renderTabs();
        renderBreakdown();
        return;
      }
    });

    elRandomizeBtn.addEventListener("click", regenerate);

    // Boot
    regenerate();
  </script>
</body>
</html>
